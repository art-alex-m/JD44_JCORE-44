# Задача 1. Понимание JVM

Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM

```java
public class JvmComprehension {

   public static void main(String[] args) {
      int i = 1;                      // 1
      Object o = new Object();        // 2
      Integer ii = 2;                 // 3
      printAll(o, i, ii);             // 4
      System.out.println("finished"); // 7
   }

   private static void printAll(Object o, int i, Integer ii) {
      Integer uselessVar = 700;                   // 5
      System.out.println(o.toString() + i + ii);  // 6
   }
}
```

### Описание

После начала выполнения программы, загрузчик классов java загружает класс JvmComprehension в область памяти Metaspace.
Далее загружает все требуемые классы и пакеты из java core: System, Object, Integer. Валидирует загруженный код
и исполняет код обозначенный статическим (System static {}). Сохраняет константные строки ("finished") в отдельную
область памяти

Затем интерпретатор находит ключевой метод main, создает для него фрейм в стеке и начинает построчно выполнять команды в
этом методе

1. Резервирует в стеке область памяти для хранения значения типа целое для переменной i, присваивает в эту область
   памяти значение равное 1
2. Резервирует в стеке область памяти для хранения указателя на тип Object, резервирует в куче место для хранения
   объекта типа Object,
   запускает конструктор по-умолчанию Object, заполняет значениями выделенное место в куче под этот объект. И
   присваивает указателю в стеке адрес памяти кучи,
   в котором храниться вновь созданный объект
3. Аналогично пункту 2. Только создается в куче объект типа Integer и ему присваивается значение 2
4. Создается в стеке новый фрейм для функции printAll и работа программы осуществляется в этом фейме. в стеке выделяется
   память для переменных o, i, ii. В эти переменные копируются значения
   для ссылочных типов - адреса на области памяти в куче, для примитивного типа int происходит копирование значения 1.
5. В стеке во фрейме printAll создается указатель uselessVar на ссылочный тип Integer, в куче создается объект типа
   Integer и ему присваивается значение 700.
   В uselessVar помещается адрес памяти в котором лежит значение.
6. Создается новый фрейм для метода o.toString(), происходит его выполнение, создается в куче объект типа строка (
   обозначим s1), возвращается указатель на строковый тип, который неявно сохраняется во фрейме printAll.
   Фрейм для метода o.toString() удаляется из стека.
   Далее происходит арифметическая операция конкатенации строк с созданием новых объектов в куче:

```java
   String s1=o.toString();
        String s2=new String(1);
        String s3=new String(s1+s2);
        String s4=new String(ii.toString()); /// так же происходит сначала создание фрейма для ii.toString() и его удаление
        String s5=new String(s3+34);
```

Далее выделяется память в стеке для метода System.out.println в него передается новой переменной адрес памяти из s5.
Происходит вывод значения на экран.
Фрейм println удаляется, происходит возврат из printAll в main и фрейм printAll удаляется. Возможно, происходит
срабатывание уборика мусора и очищение
кучи от объектов, указатели на которые хранились в uselessVar, s1-s5. Если срабатывание уборщика мусора было, то
программа приостанавливала работу для дефрагментации кучи
и изменения адресов памяти в указателях.

7. Выделяется новая память в стеке для метода System.out.println. В метод передается указатель с адресом на статическую
   строку "finished". Происходит вывод на экран. Управление возвращается в метод main.
   Фрейм памяти в стеке для println удаляется.
8. Main завершает работу. Фрейм в стеке удаляется. Программа завершает работу: очищается выделенная для программы
   память: стек, куча, метаспейс, память под константные строки.
